     1:                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     2:                    ;                                                                           ;
     3:                    ;                     Virtual Memory Kernal (VMK) v0.0.1                    ;
     4:                    ;                                                                           ;
     5:                    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
     6:                    
     7:                                           .include    "VMK.def.a65"
     8:                                           .include    "../CPUs/_CPU.def.a65"
     9:                                           .include    "../archs/_ARCH.def.a65"
    10:                                           .include    "../devices/MMUs/_MMU.def.a65"
    11:                    
    12:                    
    13:                                               ._vmk_declare_type  VMK_v1
    14:                                               ._cpu_declare_type  MOS6502
    15:                                               ._arch_declare_type SBC6502v1_4K
    16:                                               ._mmu_declare_type  MMUv1
    17:                    
    18:                    
    19:                    ;
    20:                    ; Memory Management Unit (MMU) Configutation
    21:                    ;
    22:                    
    23:                            ; 2 PID Bits, 20 Effective Address Bits, 10 Segment Offset Bits
    24:                    
    25: (0010)                     bitsPhysicalAddr   .equ     16          ; MPU65XX with 16 bit address bus (65536)
    26: (0014)                     bitsEffectiveAddr  .equ     20          ; SBC6502 with 20 bit effective address bus (1,048,576)
    27: (000A)                     bitsSegmentSize    .equ     10          ; SBC6502 with 10 bit segment size (1024)
    28: (0002)                     bitsPID            .equ     2           ; Kernal = 0x0, User = 0x1 thru 0x2
    29:                    
    30:                                               ._mmu_instantiate    bitsPhysicalAddr, bitsEffectiveAddr, bitsSegmentSize, bitsPID, list=.list
 L 133:                    
 L 134: (0010)             _mmu_bitsPhysicalAddr      .equ     16
 L 135: (0014)             _mmu_bitsEffectiveAddr     .equ     20
 L 136: (000A)             _mmu_bitsSegmentSize       .equ     10
 L 137: (0002)             _mmu_bitsPID               .equ     2
 L 138:                    
 L 139: (0006)             _mmu_bitsSegmentAddr       .equ     _mmu_bitsPhysicalAddr - _mmu_bitsSegmentSize
 L 140: (0100)             _mmu_numVectors            .equ     1 << _mmu_bitsSegmentAddr + 2
 L 141: (0080)             _mmu_configValue           .equ     (_mmu_bitsPID << 6) ! ((_mmu_bitsEffectiveAddr - _mmu_bitsPhysicalAddr) << 3) ! ((_mmu_bitsSegmentSize -8) << 0)
 L 142:                    
 L 143:                    
 L 144:                                           .segment     "_SBC6502_IO"
 L 145:  A000              _mmu
 L 146:                    
 L 147:                    ;
 L 148:                    ;   R0 - Mode Register
 L 149:                    ;
 L 150:                    ;   ┌─┬─┬───────────┐
 L 151:                    ;   │7 6 5 4 3 2 1 0│
 L 152:                    ;   └┬┴┬┴─────┬─────┘
 L 153:                    ;    │ │      └───────┤ PID (1-6 bits)
 L 154:                    ;    │ │
 L 155:                    ;    │ └──────────────┤ ~Kernal Mode (0 is enabled) / User Mode (1 is enabled)
 L 156:                    ;    │
 L 157:                    ;    └────────────────┤ ~Boot Mode (0 is enabled) / Address Translate Mode (1 is enanled)
 L 158:                    
 L 159:  A000 00           _mmu_R0                    .byte    0x00         ; Mode Register
 L 160:                    
 L 161:                    ;
 L 162:                    ;   R1 - Status Register
 L 163:                    ;
 L 164:                    ;   ┌─┬─┬─┬─┬─┬─┬─┬─┐
 L 165:                    ;   │7 6 5 4 3 2 1 0│
 L 166:                    ;   └┬┴┬┴┬┴┬┴┬┴┬┴┬┴┬┘
 L 167:                    ;    │ │ │ │ │ │ │ └──┤ Boot Address Error
 L 168:                    
 L 169:  A001 00           _mmu_R1                    .byte    0x00         ; Status Register
 L 170:                    
 L 171:                    ;
 L 172:                    ;   CR0 - Config Register 0
 L 173:                    ;
 L 174:                    ;   ┌───────┬───────┐
 L 175:                    ;   │7 6 5 4 3 2 1 0│
 L 176:                    ;   └───┬───┴───┬───┘
 L 177:                    ;       │       └─────┤ # Page Offset Bits (0-15 bits)
 L 178:                    ;       │
 L 179:                    ;       └─────────────┤ # Page Segment Bits (0-15 bits)
 L 180:                    
 L 181:  A002 00           _mmu_CR0                   .byte    0x00         ; Config Register 0
 L 182:                    
 L 183:                    ;
 L 184:                    ;   CR1 - Config Register 1
 L 185:                    ;
 L 186:                    ;   ┌───────────────┐
 L 187:                    ;   │7 6 5 4 3 2 1 0│
 L 188:                    ;   └──┬──┴────┬────┘
 L 189:                    ;      │       └──────┤ # Effective Address Bits (0-31 bits)
 L 190:                    ;      │
 L 191:                    ;      └──────────────┤ # PID Bits (0-6 bits)
 L 192:                    
 L 193:  A003 00           _mmu_CR1                   .byte    0x00         ; Config Register 1
 L 194:                    
 L 195:                    ;
 L 196:                    ;   MVR(s) - Memory Vector Register(s)
 L 197:                    ;
 L 198:                    ;                   ┌───────────────┐
 L 199:                    ;                   │7 6 5 4 3 2 1 0│─┤ MVR low
 L 200:                    ;                   └───────────────┘
 L 201:                    ;                   .               .
 L 202:                    ;   ┌───────────────┐               .
 L 203:                    ;   │7 6 5 4 3 2 1 0│─────────────────┤ MVR high
 L 204:                    ;   └───────────────┘               .
 L 205:                    ;   .               .               .
 L 206:                    ;   ┌─┬─┬─┬─────────────────────────┐
 L 207:                    ;   │5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│
 L 208:                    ;   └┬┴┬┴┬┴────────────┬────────────┘
 L 209:                    ;    │ │ │             └──────────────┤ Upper Effective Address Bits (0-13 bits)
 L 210:                    ;    │ │ │
 L 211:                    ;    │ │ └────────────────────────────┤ Page Dirty
 L 212:                    ;    │ │
 L 213:                    ;    │ └──────────────────────────────┤ Write Enable
 L 214:                    ;    │
 L 215:                    ;    └────────────────────────────────┤ Vector Enable
 L 216:                    
 L 217:                                           .align       0x10
 L 218:  A010              _mmu_vectors
 L 219:                                           .org         * + (_mmu_numVectors << 1)    ; Allocate 2 bytes for each vector.
 L 220:  A210              _mmu_vectors_
 L 221:  A210              _mmu_
 L 222:                    
 L 223:                    
 L 224:                                           .segment     "_MPU65XX_ZP"
 L 225:  0000              _mmu_parms
 L 226:  0000 00           _mmu_parms_pid             .byte    0x00
 L 227:  0001 00 00        _mmu_parms_addr            .word    0x0000
 L 228:  0003 00 00        _mmu_parms_effect_addr     .word    0x0000
 L 229:  0005              _mmu_parms_
 L 230:                    
 L 231:                    
 L 232:                                           .segment     "_SBC6502_CODE"
 L 233:                    
 L 234:  E000              _mmu_initialize
 L 235:  E000 A9 00                                    LDA     #0x00               ; Set boot mode (should already be in boot mode after hardware reset.)
 L 236:  E002 8D 00 A0                                 STA     _mmu_R0
 L 237:                    
 L 238:  E005 A9 80                                    LDA     #_mmu_configValue
 L 239:                    
 L 240:  E007 8D 01 A0                                 STA     _mmu_R1
 L 241:                    
 L 242:                                                ; Reset segment vectors ...
 L 243:                    
 L 244:  E00A A9 00                                    LDA     #0x00
 L 245:  E00C A2 00                                    LDX     #_mmu_numVectors
 L 246:  E00E                      loop
 L 247:  E00E 9D 10 A0                                 STA     _mmu_vectors, X     ; Only need to clear 2 highest bits of a segment vector.
 L 248:  E011 CA                                       DEX
 L 249:  E012 CA                                       DEX
 L 250:  E013 D0 F9                                    BNE     loop
 L 251:                    
 L 252:  E015 60                                       RTS
 L 253:                    
 L 254:                    
 L 255:  E016              _mmu_timer_initialize
 L 256:  E016 60                                       RTS
 L 257:                    
 L 258:                    
 L 259:  E017              _mmu_map_segment
 L 260:  E017 60                                       RTS
    31:                    
    32:                    ;
    33:                    ; SBC6500 Initialization (Power-Up and uP Reset (RST))
    34:                    ;
    35:                                           .segment     "_SBC6502_CODE"
    36:                    
    37:  E018              _MPU65XX_RESET
    38:  E018 78                                       SEI                 ; Disable interrupts when entering via code
    39:  E019 A2 FF                                    LDX     #0xFF       ; Initialize stack pointer
    40:  E01B 9A                                       TXS
    41:                    
    42:  E01C 20 00 E0                                 JSR     _mmu_initialize
    43:                    
    44:                    
    45:                    ; Allowcate SBC6502 segment vectors for kernal ...
    46:                    
    47:                    ;      Tag        Physical Address         Effective Address
    48:                    ;    xx00.0000 - 0000.00xx.xxxx.xxxx -> 0000.0000.00xx.xxxx.xxxx - RAM (ZP & Stack & RAM) (1Kb)
    49:                    ;    xx00.0001 - 0000.01xx.xxxx.xxxx -> 1110.1111.10xx.xxxx.xxxx - IO (1Kb)
    50:                    ;    xx00.0010 - 0000.10xx.xxxx.xxxx -> 1111.1111.00xx.xxxx.xxxx - ROM (1Kb)
    51:                    
    52:                                               ._mmu_map_segment    _vmk_kernal_pid, _SBC6502_ram, _SBC6502_eram
    53:                    
    54:                                               ._mmu_map_segment    _vmk_kernal_pid, _SBC6502_IO, _SBC6502_eio
    55:                    
    56:                                               ._mmu_map_segment    _vmk_kernal_pid, _SBC6502_rom, _SBC6502_erom
    57:                    
    58: (0008)                     curTaskSegment     .equ     8
    59:                    
    60:                    ; Initialize quantum time interrupt (IRQ) ...
    61:                    
    62:  E064 20 16 E0                                 JSR _mmu_timer_initialize
    63:                    
    64:                    ;
    65:                    ; VMK Kernal
    66:                    ;
    67:                                           .segment     "_MPU65XX_ZP"
    68:  0005                      tasks          .word
    69:  0005                      curTask        .word
    70:  0005                      curTaskRegY    .byte
    71:                    
    72:                    ;
    73:                    ; Routine for BRK or IRQ event; BRK instruction will set Break bit.
    74:                    ;
    75:                    
    76:                                           .segment     "_SBC6502_CODE"
    77:  E067              _MPU65XX_IRQ
    78:  E067              _MPU65XX_BRK
    79:                    
    80:                            ; Save current process state.
    81:                    
    82:  E067 84 05                                    STY     curTaskRegY
    83:  E069 A0 00                                    LDY     #0x00
    84:  E06B 91 05                                    STA     [curTask], Y    ; Save A
    85:  E06D A5 05                                    LDA     curTaskRegY
    86:  E06F C8                                       INY
    87:  E070 91 05                                    STA     [curTask], Y    ; Save Y
    88:  E072 8A                                       TXA
    89:  E073 C8                                       INY
    90:  E074 91 05                                    STA     [curTask], Y    ; Save X
    91:  E076 BA                                       TSX
    92:  E077 8A                                       TXA
    93:  E078 C8                                       INY
    94:  E079 91 05                                    STA     [curTask], Y    ; Save S
    95:                    
    96:  E07B AA                                       TAX
    97:  E07C BD 00 21                                 LDA     (curTaskSegment <<  bitsSegmentSize) + 0x0100, X
    98:                    
    99:  E07F 40                                       RTI
   100:                    
   101:  E080              _MPU65XX_NMI
   102:  E080 40                                       RTI
   103:                    
   104:                    
   105:                                           .include "../CPUs/MOS6502_Vectors.lib.a65", list=.list
 Q   1:                    ;
 Q   2:                    ; MOS6502 Interupt Vectors
 Q   3:                    ;
 Q   4:                                           .segment "_MPU65XX_VECTORS"
 Q   5:                    
 Q   6:  FFFA              _MPU65XX_INTERRUPT_VECTORS
 Q   7:                    
 Q   8:  FFFA 80 E0        _MPU65XX_NMI_VECTOR            .word    _MPU65XX_NMI
 Q   9:  FFFC 18 E0        _MPU65XX_RESET_VECTOR          .word    _MPU65XX_RESET
 Q  10:  FFFE              _MPU65XX_IRQ_VECTOR
 Q  11:  FFFE              _MPU65XX_BRK_VECTOR
 Q  12:  FFFE 67 E0                                       .word    _MPU65XX_IRQ
 Q  13:                    
 Q  14: (FFFF)             _MPU65XX_INTERRUPT_VECTORS_    .equ    * -1
 Q  15:                    
   106:                    
   107:                                           .end
   108:                    
