

package xcom.retro.xa.directives ;


import org.antlr.v4.runtime.ParserRuleContext ;
import org.fest.reflect.core.Reflection ;
import org.fest.reflect.exception.ReflectionError ;

import xcom.retro.xa.XA.AssemblyContext ;
import xcom.retro.xa.antlr.DirectivesBaseListener ;
import xcom.retro.xa.api.interfaces.iDirective ;
import xcom.utils4j.logging.aspects.api.annotations.Log ;
import xcom.utils4j.logging.aspects.api.annotations.NoLog ;


public class DirectiveListener extends DirectivesBaseListener {

	AssemblyContext actx ;


	public DirectiveListener(final AssemblyContext actx) {
		this.actx = actx ;
	}


	@Override
	public void enterEveryRule(final ParserRuleContext pctx) {
		invokeMethodFromContext("enter", pctx) ;
	}


	@Override
	public void exitEveryRule(final ParserRuleContext pctx) {
		invokeMethodFromContext("exit", pctx) ;
	}


	@Log
	public void invokeMethodFromContext(final String prefix, final ParserRuleContext pctx) {

		try {
			String method = pctx.getClass().getSimpleName() ;
			System.out.println(method) ;
			method = prefix + method.substring(0, method.length() - 7) ;
			Reflection.method(method).withParameterTypes(ParserRuleContext.class).in(this).invoke(pctx) ;
		}
		catch ( final ReflectionError ex ) {}
	}


	@Log
	public void exitDirective(final ParserRuleContext pctx) {

		try {
			final String phase = actx.phase().name().toLowerCase() ;
			for ( int x = 0; (x < pctx.getChildCount()); x++ ) {
				System.out.println(pctx.getChild(x).getText()) ;
		
			}

			System.out.println() ;
			final String name = (pctx.getChild(0).getText().equals(".") ? pctx.getChild(1).getText() : pctx.getChild(2).getText()).toLowerCase() ;
			System.out.println("exit directive: " + name + " @" + phase) ;
			iDirective directive = actx.directives().get(name + "Directive") ;
//			System.out.println("directive: " + directive) ;
//			System.out.println("macros: " + actx.macros().keySet()) ;
//			System.out.println("macros: "+ actx.getMacros().size()) ;

			if ( directive == null )
				directive = actx.macros().get(name) ;

			System.out.println("directive: " + directive) ;


			Reflection.method(phase).withParameterTypes(ParserRuleContext.class).in(directive).invoke(pctx) ;

//			System.out.println(actx.getStatement()) ;
//			System.out.println(actx.getDirectives().keySet()) ;
//			System.out.println("macros_: "+ actx.getMacros().hashCode() + ": "+ actx.getMacros().keySet()) ;
//			System.out.println("macros_: "+ actx.getMacros().size()) ;
		}
		catch ( final ReflectionError ex ) {
//			catch ( final Throwable ex ) {
			ex.printStackTrace() ;
		}
	}


	@Log
	public void exitMacroDirective(final ParserRuleContext pctx) {}
}
