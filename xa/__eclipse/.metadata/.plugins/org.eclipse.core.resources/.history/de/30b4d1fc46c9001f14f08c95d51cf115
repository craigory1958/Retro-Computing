

package xcom.retro.xa.ParsingChecks ;


import static org.junit.Assert.assertArrayEquals ;

import java.io.IOException ;
import java.util.ArrayList ;
import java.util.Arrays ;
import java.util.Collection ;
import java.util.List ;

import org.junit.BeforeClass ;
import org.junit.Test ;
import org.junit.runner.RunWith ;
import org.junit.runners.Parameterized ;


@RunWith(Parameterized.class)
public class _Test_AddressingModes_MOS6502 {

	@Parameterized.Parameters()
	public static Collection<Object[]> data() {

		//@formatter:off

        final Object[][] results = {

                // { String mode,  String src, String[] expectedContexts }

//                { "        Imm", " ADC #xxx",     "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "        Abs", " ADC xxx",      "Statement, Instruction, Opcode, AddressingMode, Absolute, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "         ZP", " ADC zp",       "Statement, Instruction, Opcode, AddressingMode, Absolute, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "        Acc", " ASL A",        "Statement, Instruction, Opcode, AddressingMode, Accumulator" },
//                { "        Imp", " BRK",          "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
                { "[ZP Ind ,X]", " ADC [zp, X]",  "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
                { "[ZP Ind] ,Y", " ADC [zp], Y",  "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "      ZP, X", " ADC zp, X",    "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "     Abs, X", " ADC xxx, X",   "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "     Abs, Y", " ADC xxx, Y",   "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "        Rel", " BCC xxx",      "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
//                { "      ZP, Y", " LDX zp, Y",    "Statement, Instruction, Opcode, AddressingMode, Immediate, Argument, Expr, Term, Literal, NumericLiteral, HexLiteral" },
           } ;

        //@formatter:on

		return (Arrays.asList(results)) ;
	}


	String mode ;
	String src ;
	List<String> expectedContexts ;

	static ParsingScaffold parser ;


	public _Test_AddressingModes_MOS6502(String mode, String src, String expectedContexts) {

		this.mode = mode ;
		this.src = src ;

		this.expectedContexts = new ArrayList<String>(Arrays.asList(expectedContexts.split(", "))) ;
	}


	@BeforeClass
	public static void setupBeforeClass() throws Exception {

		parser = new ParsingScaffold() ;
		parser.init("MOS6502", "v1") ;
	}


	@Test
	public void parseTest() throws IOException {

		List<String> actual = parser.parse("statement", src).processor.walked ;
		System.out.println(mode + ": " + src + " - " + actual) ;

		assertArrayEquals(expectedContexts.toArray(), actual.toArray()) ;
	}
}
